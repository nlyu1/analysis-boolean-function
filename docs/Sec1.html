<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Fourier Expansion for General Domain | Analysis of Boolean Functions</title>
  <meta name="description" content="1 Fourier Expansion for General Domain | Analysis of Boolean Functions" />
  <meta name="generator" content="bookdown 0.39 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Fourier Expansion for General Domain | Analysis of Boolean Functions" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Fourier Expansion for General Domain | Analysis of Boolean Functions" />
  
  
  

<meta name="author" content="Nicholas Lyu" />


<meta name="date" content="2024-06-02" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="influence-and-spectral-learning.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#notation"><i class="fa fa-check"></i>Notation</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="Sec1.html"><a href="Sec1.html"><i class="fa fa-check"></i><b>1</b> Fourier Expansion for General Domain</a>
<ul>
<li class="chapter" data-level="1.1" data-path="Sec1.html"><a href="Sec1.html#boolean-function"><i class="fa fa-check"></i><b>1.1</b> Boolean function</a>
<ul>
<li class="chapter" data-level="" data-path="Sec1.html"><a href="Sec1.html#natural-and-parity-bases"><i class="fa fa-check"></i>Natural and parity bases</a></li>
<li class="chapter" data-level="" data-path="Sec1.html"><a href="Sec1.html#fourier-formulas"><i class="fa fa-check"></i>Fourier formulas</a></li>
<li class="chapter" data-level="" data-path="Sec1.html"><a href="Sec1.html#relative-densities-and-convolution"><i class="fa fa-check"></i>Relative densities and convolution</a></li>
<li class="chapter" data-level="" data-path="Sec1.html"><a href="Sec1.html#almost-linear-functions-property-testing-and-blr"><i class="fa fa-check"></i>Almost linear functions, property testing, and BLR</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="influence-and-spectral-learning.html"><a href="influence-and-spectral-learning.html"><i class="fa fa-check"></i><b>2</b> Influence and Spectral Learning</a>
<ul>
<li class="chapter" data-level="2.1" data-path="influence-and-spectral-learning.html"><a href="influence-and-spectral-learning.html#Sec2"><i class="fa fa-check"></i><b>2.1</b> Influence, Noise Stablity, and Social Choice</a>
<ul>
<li class="chapter" data-level="" data-path="influence-and-spectral-learning.html"><a href="influence-and-spectral-learning.html#social-choice-functions"><i class="fa fa-check"></i>Social choice functions</a></li>
<li class="chapter" data-level="" data-path="influence-and-spectral-learning.html"><a href="influence-and-spectral-learning.html#dependence-properties"><i class="fa fa-check"></i>Dependence properties</a></li>
<li class="chapter" data-level="" data-path="influence-and-spectral-learning.html"><a href="influence-and-spectral-learning.html#influence-and-derivatives"><i class="fa fa-check"></i>Influence and derivatives</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Analysis of Boolean Functions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="Sec1" class="section level1 hasAnchor" number="1">
<h1><span class="header-section-number">1</span> Fourier Expansion for General Domain<a href="Sec1.html#Sec1" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>This section corresponds to chapters <span class="math inline">\(1\)</span> and <span class="math inline">\(8\)</span>.
We demonstrating how the space of Boolean functions
<span class="math inline">\(\mathcal P\to \mathbb R\)</span> form a Hilbert space, and then generalize this construction.</p>
<div id="boolean-function" class="section level2 hasAnchor" number="1.1">
<h2><span class="header-section-number">1.1</span> Boolean function<a href="Sec1.html#boolean-function" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="natural-and-parity-bases" class="section level3 unnumbered hasAnchor">
<h3>Natural and parity bases<a href="Sec1.html#natural-and-parity-bases" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Fix <span class="math inline">\(n\)</span> and consider Boolean functions <span class="math inline">\(\mathcal P^n\to \mathcal P\)</span>.
Without loss of generality we may expand their range to <span class="math inline">\(\mathbb F\in \{\mathbb R, \mathbb C\}\)</span>
and define
<span class="math display">\[
    L^2(\mathcal P^n) = \{\text{all functions $\mathcal P^n\to \mathbb F$}\}
\]</span>
Addition and scalar multiplication are defined in the most obvious way.</p>
<div class="definition">
<p><span id="def:unlabeled-div-1" class="definition"><strong>Definition 1.1  (natural basis of boolean functions) </strong></span>Let <span class="math inline">\(I_y\)</span> where <span class="math inline">\(y\in \mathcal P^n\)</span> denote the indicator polynomial
<span class="math display">\[
    I_y(x) = \begin{cases}
        1 &amp; x = y \\ 0 &amp; \text{else}
    \end{cases}
\]</span>
The indicator polynomials form the natural basis for boolean functions,
since for all <span class="math inline">\(f\in L^2(\mathcal P^n)\)</span>
<span class="math display">\[
    f(x) = f(y)I_y(x) \implies f = f(y)I_y
\]</span>
Note the implicit sum over <span class="math inline">\(y\in \mathcal P^n\)</span>.</p>
</div>
<p>Let <span class="math inline">\(x_i(y) = y_i, i\in [n]\)</span>; this is overloading the notation, as
<span class="math inline">\(x_i\)</span> can now both be a function or an input variable, depending on context.</p>
<div class="definition">
<p><span id="def:unlabeled-div-2" class="definition"><strong>Definition 1.2  (parity function) </strong></span>Given <span class="math inline">\(J\in \mathcal P^n\)</span>, define the parity function <span class="math inline">\(\chi_J:\mathcal P^n\to \mathbb F\)</span>.
<span class="math display">\[
    \chi_J = \prod_{J_i=1} x_i \implies \chi_J(x) = (-1)^{J\cdot x}
\]</span>
Every indicator function can be expanded in parity functions
<span class="math display" id="eq:indicator">\[\begin{equation}
   I_y = \prod_{i=1}^n \dfrac{1+y_ix_i}{2} \impliedby (\exists i: x_i\neq y_i\implies I_y=0)
   \tag{1.1}
\end{equation}\]</span>
As a consequence, every indicator function <span class="math inline">\(I_y\)</span>, thus every
boolean function, can be expanded as a
multi-linear polynomial in <span class="math inline">\((x_j)\)</span>. Note that multilinearity is due
to the multilinearity of the indicator expansion <a href="Sec1.html#eq:indicator">(1.1)</a> and the
fact that in the <span class="math inline">\(\mathbb F_2\)</span> representation, <span class="math inline">\(x_i^2=1\)</span>.</p>
</div>
</div>
<div id="fourier-formulas" class="section level3 unnumbered hasAnchor">
<h3>Fourier formulas<a href="Sec1.html#fourier-formulas" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="theorem">
<p><span id="thm:unlabeled-div-3" class="theorem"><strong>Theorem 1.1  (fourier expansion of boolean functions) </strong></span>Every boolean function <span class="math inline">\(f\in L^2(\mathcal P^n)\)</span> is a unique linear combination of parity functions
<span class="math display">\[
    f = \widehat f(J) \chi_J
\]</span>
The coefficients <span class="math inline">\(\widehat f(J)\)</span> form the <em>fourier spectrum</em> of <span class="math inline">\(f\)</span>. Equivalently,
<span class="math inline">\(\widehat f\in L^2(\mathbb F^n)\)</span> is the <em>fourier transform</em> of <span class="math inline">\(f\)</span>. Note that the range of <span class="math inline">\(\widehat f\)</span>
is in general not <span class="math inline">\(\mathcal P\)</span>.</p>
</div>
<p><em>Proof:</em> Note that <span class="math inline">\(\dim L^2(\mathcal P^n) = 2^n\)</span>.
The natural basis <span class="math inline">\((I_J)\)</span> and parity basis <span class="math inline">\((\chi_J)\)</span> both contain <span class="math inline">\(2^n\)</span>
elements and there is a linear transformation between them, so both are bases
for <span class="math inline">\(L^2(\mathcal P^n)\)</span>.</p>
<div class="remark">
<p><span id="unlabeled-div-4" class="remark"><em>Remark</em> (product structure of fourier basis). </span>Note that the parity basis function <span class="math inline">\(\chi_J\)</span> is a product of elements which are supported on
(dependent upon) only a component of the input. This is not true of the natural basis.</p>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-5" class="definition"><strong>Definition 1.3  (natural and fourier expansions of max) </strong></span>Consider <span class="math inline">\(\max_2\)</span> with <span class="math inline">\(\max_2(x, y)=-1\)</span> if <span class="math inline">\(x=y=-1\)</span> else <span class="math inline">\(1\)</span>.
Using the formula above
<span class="math display">\[\begin{align}
    {\max}_2
    &amp;= I_{(1, 1)} + I_{(1, -1)} + I_{(-1, 1)} - I_{(-1, -1)}  \\
    &amp;= \dfrac 1 4 (1+x_1)(1+x_2) + \dfrac 1 4 (1+x_1)(1-x_2) + \dfrac 1 4 (1-x_1)(1+x_2) - \dfrac 1 4 (1-x_1)(1-x_2) \\
    &amp;= \cdots = \dfrac 1 2 (1 + x_1 + x_2 - x_1x_2)
\end{align}\]</span></p>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-6" class="definition"><strong>Definition 1.4  (inner product) </strong></span>Define the inner product <span class="math inline">\(\langle\cdot, \cdot\rangle: L^2(\mathcal P^n)\times L^2(\mathcal P^n)\to \mathbb F\)</span> via
<span class="math display">\[
    \langle f | g\rangle= \dfrac 1 {2^n} \langle f(x)|g(x)\rangle
\]</span>
Again, note the implicit sum over <span class="math inline">\(x\)</span>. Here <span class="math inline">\(\langle f(x)|g(x)\rangle\)</span> is the inner product on <span class="math inline">\(\mathbb F\)</span>
<span class="math display">\[
    \langle a|b\rangle= \begin{cases}
        ab &amp; \mathbb F=\mathbb R\\
        a^*b &amp; \mathbb F=\mathbb C
    \end{cases}
\]</span>
In most generality <span class="math inline">\(\mathbb F=\mathbb C\)</span>, in which case
<span class="math inline">\(\langle f|g\rangle= \mathbb E[f(\mathbf x)^*g(\mathbf x)]\)</span>.
Norms are defined naturally
<span class="math display">\[
    \|f\|_p = \mathbb E[|f(\mathbf x)|^{p}]^{1/p}
\]</span></p>
</div>
<p>The indicator basis is apparantly orthonormal since <span class="math inline">\(I_xI_y=0\)</span> if <span class="math inline">\(x\neq y\)</span>.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-7" class="theorem"><strong>Theorem 1.2  (orthonormality of fourier basis) </strong></span><span class="math inline">\(\langle\chi_J|\chi_K\rangle= \delta_{JK}\)</span>.</p>
</div>
<p><em>Proof:</em> Using <span class="math inline">\(x_j^2=1\)</span>, we obtain <span class="math inline">\(\chi_J\chi_K=\chi_{J\Delta K}\)</span>.
We further have <span class="math inline">\(\mathbb E[\chi_J(\mathbf x)] = \delta_{J 0}\)</span>, then
<span class="math display">\[
    \langle\chi_J|\chi_K\rangle= \mathbb E[\chi_J(\mathbf x)\chi_K(\mathbf x)] =
    \mathbb E[\chi_{J\Delta K}(\mathbf x)] = \delta_{0(J\Delta K)} = \delta_{JK}
\]</span></p>
<p>One may also verify that this is non-degenerate, bilinear and (skew)-symmetric.
The usual projection and norm formulas follow.</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-8" class="theorem"><strong>Theorem 1.3  (Parseval's theorem) </strong></span><span class="math inline">\(\|f\|_2^2 = \mathbb E[|f(\mathbf x)|^2] = \sum_J |\widehat f(J)|^2\)</span>
In particular, if <span class="math inline">\(f\)</span> is boolean-valued (range in <span class="math inline">\(\mathbb F_2\)</span>) then
<span class="math inline">\(\langle f|f\rangle= 1\)</span>.</p>
</div>
<div class="theorem">
<p><span id="thm:unlabeled-div-9" class="theorem"><strong>Theorem 1.4  (Plancherel's theorem) </strong></span><span class="math inline">\(\langle f|g\rangle= \mathbb E[f(\mathbf x)^*g(\mathbf x)] = \widehat f(J)^*g(J)\)</span></p>
</div>
<div class="definition">
<p><span id="def:hammingDistance" class="definition"><strong>Definition 1.5  (Hamming distance) </strong></span>Define the Hamming distance between two boolean functions <em>with range <span class="math inline">\(\mathcal P\)</span></em>
<span class="math display">\[
    \mathrm{dist}(f, g) = \Pr[f(\mathbf x)\neq g(\mathbf x)]
\]</span>
Note that <span class="math inline">\(\langle f|g\rangle= 1 - 2\, \mathrm{dist}(f, g)\)</span>.</p>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-10" class="definition"><strong>Definition 1.6  (boolean function statistics) </strong></span>A boolean function, viewed as <span class="math inline">\(f(\mathbf x)\)</span>, is also a real-valued discrete
random variable. Its statistics are defined in the most obvious ways</p>
<ul>
<li><span class="math inline">\(\mathbb E[f] = \widehat f(0)\)</span>; here we are using <span class="math inline">\(\mathbb F_2\)</span> and <span class="math inline">\(\mathcal P\)</span> interchangeably.
This is the constant term in the fourier expansion of <span class="math inline">\(f\)</span> about <span class="math inline">\(\mathbb F_2\)</span> representation.</li>
<li><span class="math inline">\(\mathrm{Cov}(f, g) = \langle f |g\rangle- \mathbb E[f]\mathbb E[g] = \sum_{J\neq 0} \widehat f(J)^* g(\mathbf J)\)</span>.</li>
</ul>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-11" class="definition"><strong>Definition 1.7  (fourier weight, spectral sample, degree weight) </strong></span>The (fourier) weight of <span class="math inline">\(f\)</span> on a set <span class="math inline">\(J\)</span> is simply <span class="math inline">\(|\widehat f(J)|^2\)</span>.
In particular, Parsevalâ€™s theorem implies that the fourier weight of a boolean function
defines a probability distribution on the Hamming cube, which may be identified
with the power set <span class="math inline">\(\mathcal P([n])\)</span>.</p>
<p>The spectral sample <span class="math inline">\(\mathbf S_f\)</span> is the probability distribution over <span class="math inline">\(\mathcal P([n])\)</span>
according to <span class="math inline">\(\widehat f\)</span>.</p>
<p>Each multi-index <span class="math inline">\(J\)</span> has a degree (its polynomial degree in <span class="math inline">\((x_j)\)</span>).
The fourier weight of <span class="math inline">\(f\)</span> at degree <span class="math inline">\(k\)</span> is
<span class="math display">\[
    \mathbf W^k[f] = \sum_{|J|=k} |\widehat f(J)|^2 = \Pr_{S\sim \mathcal S_f}[|S|=k]
\]</span></p>
</div>
</div>
<div id="relative-densities-and-convolution" class="section level3 unnumbered hasAnchor">
<h3>Relative densities and convolution<a href="Sec1.html#relative-densities-and-convolution" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>For this section we use <span class="math inline">\(\mathcal B\)</span> instead of <span class="math inline">\(\mathcal P\)</span> to represent the boolean
domain, so that addition is the natural operation.</p>
<div class="definition">
<p><span id="def:unlabeled-div-12" class="definition"><strong>Definition 1.8  (density function) </strong></span>A (relative probability) density function on the Hamming cube <span class="math inline">\(\mathcal P^n\)</span>
is a nonnegative function satisfying <span class="math inline">\(\mathbb E[\varphi(\mathbf x)] = 1\)</span>.
In this case we interchangeably write <span class="math inline">\(\varphi\)</span> as a density function itself.</p>
</div>
<p>Given density <span class="math inline">\(\varphi\)</span>, note that
<span class="math display">\[
    \mathbb E_{\mathbf y\sim \varphi}[g(\mathbf y)] = \dfrac 1 {2^n} \varphi(y)g(y)
    = \langle\varphi, g\rangle
\]</span></p>
<div class="definition">
<p><span id="def:unlabeled-div-13" class="definition"><strong>Definition 1.9  (indicator function) </strong></span>Given <span class="math inline">\(A\subset \mathcal B^n\)</span>, let <span class="math inline">\(1_A:\mathcal B^n\to \mathcal B\)</span> for the <span class="math inline">\((0, 1)\)</span> indicator
function.
For <span class="math inline">\(A\neq \emptyset\)</span>, denote by <span class="math inline">\(\varphi_A = 1_A/\mathbb E[1_A]\)</span> the
density function associated with uniform distribution over <span class="math inline">\(A\)</span>.</p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-14" class="example"><strong>Example 1.1  (singleton density) </strong></span>Let <span class="math inline">\(\{0\}\subset \mathcal B^n\)</span> denote the singleton set of the vector
with all entries <span class="math inline">\(0\)</span>
<span class="math display">\[
    \varphi_{\{0\}}(y)
    = 2^n I_{\{0\}}(y) = 2^n \prod (1+y_j) = \sum_J \chi_J(y)
\]</span>
Note that <span class="math inline">\(\pm\)</span> are equivalent in the <span class="math inline">\(\mathcal B\)</span> algebra.</p>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-15" class="definition"><strong>Definition 1.10  (convolution) </strong></span>Given <span class="math inline">\(f, g:\mathcal B^n\to \mathbb R\)</span>, define <span class="math inline">\(f\ast g:\mathcal P^n\to \mathbb R\)</span> by
<span class="math display" id="eq:bitConvolution">\[\begin{equation}
    (f\ast g)(x) = \mathbb E[f(\mathbf y)g(x\pm \mathbf y)]
    \tag{1.2}
\end{equation}\]</span>
The counterpart for <span class="math inline">\(f, g\in \mathcal P^n\to \mathbb R\)</span> is
<span class="math inline">\((f\ast g)(x) = \mathbb E[f(\mathbf y)g(x\mathbf y)]\)</span>.
Note that if <span class="math inline">\(\varphi\)</span> is a density function, then
<span class="math display">\[
    (\varphi \ast g)(x) = \mathbb E_{y\sim \varphi}[g(x+\mathbf y)]
    \implies \mathbb E_{\mathbf y\sim \varphi}[g(\mathbf y)] = (\varphi \ast g)(0)
\]</span></p>
</div>
<div class="theorem">
<p><span id="thm:unlabeled-div-16" class="theorem"><strong>Theorem 1.5  (fourier theorem) </strong></span>Given <span class="math inline">\(f, g:\mathcal B^n\to \mathbb C\)</span>, for all <span class="math inline">\(J\)</span>
<span class="math display">\[
    \widehat{f\ast g}(J) = \widehat f(J) \widehat g(J)
\]</span></p>
</div>
<p><em>Proof:</em> Using the projection formula, definition, substitute
<span class="math inline">\(\mathbf z=\mathbf x - \mathbf y\)</span>, and <span class="math inline">\(\chi_J(x+y)=J\cdot (x+y) = \chi_J(x)\chi_J(y)\)</span>
<span class="math display">\[\begin{align}
    \widehat{f\ast g}(J)
    &amp;= \mathbb E_{\mathbf x}[(f\ast g)(\mathbf x) \chi_J(\mathbf x)]
    = \mathbb E_{\mathbf{x, y}}[f(\mathbf y)g(\mathbf x - \mathbf y) \chi_J(\mathbf x)] \\
    &amp;= \mathbb E_{\mathbf{x, z}}[f(\mathbf y)g(\mathbf z)\chi_J(\mathbf z + \mathbf y)] \\
    &amp;= \mathbb E_{\mathbf{x, z}}[f(\mathbf y)\chi_J(\mathbf y) f(\mathbf z)\chi_J(\mathbf z)]
    = \widehat f(J)\widehat g(J)
\end{align}\]</span></p>
<p>This suffices to prove that convolution is associative and commutative.</p>
</div>
<div id="almost-linear-functions-property-testing-and-blr" class="section level3 unnumbered hasAnchor">
<h3>Almost linear functions, property testing, and BLR<a href="Sec1.html#almost-linear-functions-property-testing-and-blr" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="definition">
<p><span id="def:unlabeled-div-17" class="definition"><strong>Definition 1.11  ((approximate) linearity of boolean functions) </strong></span>A function <span class="math inline">\(f:\mathcal B^n\to \mathcal B\)</span> is linear if either of the following conditions hold:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\forall x, y: f(x+y) = f(x)+f(y)\)</span></li>
<li><span class="math inline">\(f(x) = a\cdot x\)</span> for some <span class="math inline">\(a\in \mathcal B^n\)</span></li>
</ol>
<p>These conditions are indeed equivalent: <span class="math inline">\(2\implies 1\)</span> is trivial. Given <span class="math inline">\(1\)</span>,
define <span class="math inline">\((e_j)_k=\delta_{jk}\)</span>, then <span class="math inline">\((2)\)</span> is satisfied by <span class="math inline">\(a_j=f(e_j)\)</span>.</p>
<p>We propose two definitions of approximately linear:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(f(x+y)=f(x)+f(y)\)</span> for almost all pairs <span class="math inline">\(x, y\)</span></li>
<li>For some <span class="math inline">\(a\)</span>, <span class="math inline">\(f(x)=a\cdot x\)</span> for almost all <span class="math inline">\(x\)</span>.</li>
</ol>
<p>Here <span class="math inline">\(2\implies 1\)</span> is robust: if <span class="math inline">\((2)\)</span> is satisfied for <span class="math inline">\(x, y\)</span>, then
<span class="math inline">\(1\)</span> is satisfied for the pair, too.
The converse is not papparant but nevertheless true.</p>
</div>
<div class="definition">
<p><span id="def:unlabeled-div-18" class="definition"><strong>Definition 1.12  (closeness) </strong></span>Recalling the Hamming distance <a href="Sec1.html#def:hammingDistance">1.5</a>.
Two boolean functions are <span class="math inline">\(\epsilon\)</span>-close of <span class="math inline">\(\mathrm{dist}(f, g)\leq \epsilon\)</span>
otherwise <span class="math inline">\(\epsilon\)</span>-far. Given a nonempty property <span class="math inline">\(P\)</span> on <span class="math inline">\(n\)</span>-bit
Boolean functions, define
<span class="math display">\[
    \mathrm{dist}(f, P) = \min_{g\in P} \mathrm{dist}(f, g)
\]</span></p>
</div>
<p>We define approximate linearity by criterion (2) above: <span class="math inline">\(f\)</span> is
<span class="math inline">\(\epsilon\)</span>-close to being linear if there is a linear function <span class="math inline">\(x\mapsto a\cdot x\)</span>
which is less than <span class="math inline">\(\epsilon\)</span>-close to <span class="math inline">\(f\)</span>.
The test below shows that <span class="math inline">\(1\implies 2\)</span> above:</p>
<div class="theorem">
<p><span id="thm:unlabeled-div-19" class="theorem"><strong>Theorem 1.6  (BLR test) </strong></span>The BLR procedure tests for linearity as follows:</p>
<ul>
<li>Choose <span class="math inline">\(\mathbf{x, y}\in \mathcal B^n\)</span> independently.</li>
<li>Query <span class="math inline">\(f\)</span> at <span class="math inline">\(\mathbf{x, y}, \mathbf x + \mathbf y\)</span>.</li>
<li>Accept if <span class="math inline">\(f(\mathbf x)+f(\mathbf y) = f(\mathbf x + \mathbf y)\)</span>.</li>
</ul>
<p>If BLR test accepts <span class="math inline">\(f\)</span> with probability <span class="math inline">\(1-\epsilon\)</span>, then <span class="math inline">\(f\)</span>
is <span class="math inline">\(\epsilon\)</span>-close to being linear.</p>
</div>
<p><em>Proof:</em> Encode output by <span class="math inline">\(\pm 1\)</span> so that acceptance condition becomes
<span class="math inline">\(f(\mathbf x)f(\mathbf y) = f(\mathbf x + \mathbf y)\)</span>, then
<span class="math display">\[
    \dfrac 1 2 + \dfrac 1 2 f(\mathbf x)f(\mathbf y)f(\mathbf x + \mathbf y)
    = \begin{cases}
        1 &amp; f(\mathbf x)f(\mathbf y) = f(\mathbf x + \mathbf y) \\
        0 &amp; \text{otherwise}
    \end{cases}
\]</span>
Note that the input representation is still <span class="math inline">\(\mathcal B\)</span> so formula
<a href="Sec1.html#eq:bitConvolution">(1.2)</a> still applies, then
<span class="math display">\[\begin{align}
    1-\epsilon
    &amp;= \Pr(\text{accept})
    = \dfrac 1 2 + \dfrac 1 2 \mathbb E_{\mathbf x}[f(\mathbf x) \mathbb E_{\mathbf y}[f(\mathbf y)f(\mathbf x + \mathbf y)]] \\
    &amp;= \dfrac 1 2 + \dfrac 1 2 \mathbb E_{\mathbf x}[f(\mathbf x) (f\ast f)(\mathbf x)]  \\
    &amp;= \dfrac 1 2 + \dfrac 1 2 \langle f, f\ast f\rangle= \dfrac 1 2 + \dfrac 1 2 \sum_J \hat f(J)^3 \\
    1 - 2\epsilon
    &amp;= \sum_J \hat f(J)^3 \leq [\max_K \hat f(K)] \sum_J \hat f(J)^2 = \max_K \hat f(K)
\end{align}\]</span>
For the last equation we used <span class="math inline">\(\sum \hat f(J)^2 = \langle f, f\rangle= \mathbb E[f^2] = 1\)</span>.
Now, recall that all linear functions are of the form <span class="math inline">\(\chi_J\)</span>, then
<span class="math display">\[
    1 - 2\epsilon \max_K \hat f(K) = \max_K \langle f, \chi_K\rangle= \max_K [1 - 2\mathrm{dist}(f, \chi_K)]
    = 1 - 2\min_K \mathrm{dist}(f, \chi_K)
\]</span>
It follows that <span class="math inline">\(\epsilon \geq \min_K \mathrm{dist}(f, \chi_K)\)</span>.</p>
<p>If <span class="math inline">\(f\)</span> is <span class="math inline">\(\epsilon\)</span>-close to <span class="math inline">\(\chi_J\)</span>, we can determine <span class="math inline">\(\chi_J(x)\)</span>
with high probability for a given <span class="math inline">\(x\)</span> using the following procedure:</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-20" class="proposition"><strong>Proposition 1.1  (local correctibility of linear functions) </strong></span>Suppose <span class="math inline">\(f:\mathcal B^n\to \mathcal P\)</span> is <span class="math inline">\(\epsilon\)</span>-close to <span class="math inline">\(\chi_J\)</span>, then
for every <span class="math inline">\(x\in \mathcal B^n\)</span>, the following procedure outputs <span class="math inline">\(\chi_J(x)\)</span> with
probability at least <span class="math inline">\(1-2\epsilon\)</span>:</p>
<ol style="list-style-type: decimal">
<li>Choose <span class="math inline">\(\mathbf y\sim \mathcal B^n\)</span></li>
<li>Query <span class="math inline">\(f\)</span> at <span class="math inline">\(\mathbf y\)</span> and <span class="math inline">\(x+\mathbf y\)</span></li>
<li>Output <span class="math inline">\(f(\mathbf y)f(x+\mathbf y)\)</span>
Note that even if <span class="math inline">\(f(x)\neq \chi_J(x)\)</span>, the procedure above is still able to
determine <span class="math inline">\(\chi_J(x)\)</span> with high probability based on <span class="math inline">\(f\)</span>.</li>
</ol>
</div>
<p><em>Proof:</em> The probability that <span class="math inline">\(f(x+\mathbf y)\neq \chi_J(x+\mathbf y)\)</span> and
<span class="math inline">\(f(\mathbf y)\neq \chi_J(\mathbf y)\)</span> is upper-bounded by <span class="math inline">\(1-2\epsilon\)</span>.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="influence-and-spectral-learning.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
